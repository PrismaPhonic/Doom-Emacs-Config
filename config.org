#+title: Doom Emacs Configuration
#+AUTHOR: Peter Farr

* Startup Performance

#+begin_src emacs-lisp

;; The default is 800 kilobytes.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))

(defun pmf/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'pmf/display-startup-time)

#+end_src

* Personal Information

Set my name and email for use by emacs where applicable. Some configuration use this to identify me (GPG configuration, email clients etc.)

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Peter Farr"
      user-mail-address "farr.peterm@gmail.com")
#+END_SRC

* Authinfo

In emacs there's a standard by which you can store confidential information in a gpg encrypted file. You can read about how to set it up [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Authentication.html][here]].

Throughout this configuration I'll provide specifics for various packages that require confidential information, and how they expect it to be setup in your authinfo file.

Note that if you encrypt it with gpg, you should be able to edit it as if it were a normal file in emacs, and emacs will automatically handle decryption on read and encryption on write for you.
* Utilities

These go early in flow in case they get called later on

** Toggle file split

This is a helper to automatically pull up a file in a split. Calling the helper again closes the split - causing it act like a toggle

#+begin_src emacs-lisp
(defun my/toggle-file-split (filepath)
  "Toggle horizontal split showing FILEPATH.
If it's visible, close it. Otherwise, open in a horizontal split."
  (interactive "fPath to file: ")
  (let* ((fullpath (expand-file-name filepath))
         (buf (or (find-buffer-visiting fullpath)
                  (find-file-noselect fullpath)))
         (win (get-buffer-window buf t))) ;; search all visible frames
    (if win
        (delete-window win)
      (let ((new-win (split-window-below)))
        (set-window-buffer new-win buf)
        (select-window new-win)))))

(map! :leader
      :desc "Toggle gtd tasks"
      "o g" (lambda () (interactive) (my/toggle-file-split "~/org/gtd/org-gtd-tasks.org"))
      :desc "Toggle jira issues"
      "o j" (lambda () (interactive) (my/toggle-file-split "~/.org-jira/AUTH.org")))
#+end_src

** Org to Markdown Scratchpad

This provides a neat scratchpad that auto converts to markdown. Useful if you want to generate markdown for a slack buffer or other use cases. Partially this is because I can't use emacs everywhere with wayland (yet).

#+BEGIN_SRC emacs-lisp

(defun my/org-md-scratchpad ()
  "Open Org buffer, export to Markdown via Pandoc, clean output, copy to clipboard, and clean up."
  (interactive)
  (let* ((buf (generate-new-buffer "*org-md-scratchpad*"))
         (win (split-window-below)))
    (select-window win)
    (switch-to-buffer buf)
    (org-mode)
    (insert "#+BEGIN_SRC shell :results verbatim :exports both\n#+END_SRC")
    (goto-char (point-max))
    ;; Setup C-c C-c to export + copy
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map org-mode-map)
      (define-key map (kbd "C-c C-c")
                  (lambda ()
                    (interactive)
                    (let* ((scratchpad-buf (current-buffer))
                           (tmp-org (make-temp-file "scratchpad" nil ".org"))
                           (tmp-md (make-temp-file "scratchpad" nil ".md")))
                      (condition-case err
                          (progn
                            ;; Evaluate code blocks
                            (let ((org-confirm-babel-evaluate nil))
                              (org-babel-execute-buffer))
                            ;; Write Org content to temp file
                            (write-region (point-min) (point-max) tmp-org nil 'quiet)
                            ;; Run Pandoc with clean formatting options
                            (call-process "pandoc" nil nil nil
                                          tmp-org "-f" "org" "-t" "markdown"
                                          "-o" tmp-md
                                          "--wrap=none"
                                          "--markdown-headings=atx")
                            ;; Read final result and copy
                            (with-temp-buffer
                              (insert-file-contents tmp-md)
                              (kill-new (buffer-string)))
                            (message "‚úÖ Markdown copied to clipboard.")
                            ;; Cleanup
                            (kill-buffer scratchpad-buf)
                            (when (window-live-p win)
                              (delete-window win)))
                        (error (message "‚ùå Export failed: %s" (error-message-string err)))))))
      (use-local-map map))))

;; Opens org to markdown scratch pad.
(map! :leader
      :desc "Org to markdown scratchpad"
      "o o" (lambda () (interactive) (my/org-md-scratchpad)))

#+END_SRC

** Set Dictionary

This sets the dictionary for spelling correction

#+begin_src emacs-lisp

(setq ispell-program-name "hunspell")
(setq ispell-dictionary "en_US")

#+end_src

* UI Configuration

** Color Theme


#+begin_src emacs-lisp

(setq doom-theme 'doom-oceanic-next)

#+end_src

** Fonts
#+BEGIN_SRC emacs-lisp

(setq doom-font (font-spec :family "Monaspace Neon" :size 16 :weight 'light)
      doom-variable-pitch-font (font-spec :family "Monaspace Argon" :size 17)
      doom-serif-font (font-spec :family "Monaspace Xenon" :size 17))

#+END_SRC

** Relative line numbers

#+begin_src emacs-lisp

(setq display-line-numbers-type 'relative)

#+end_src

* Browser Integration

I found that I needed to explicitly bind this to get my system browser to pop up when going to web links

#+BEGIN_SRC emacs-lisp

;; Enforce that emacs uses the system default browser set with
;; $ xdg-settings set default-web-browser firefox-developer-edition.desktop
(setq browser-url-browser-function 'browse-url-default-browser)

#+END_SRC

* Org Mode

[[https://orgmode.org/][Org Mode]] is one of the hallmark features of Emacs.  It is a rich document editor, project planner, task and time tracker, blogging engine, and literate coding utility all wrapped up in one package.

** Better Font Faces

The =pmf/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+begin_src emacs-lisp

(defun pmf/org-font-setup ()
  ;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.1)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.0)
                  (org-level-6 . 1.0)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch :height 1.0)
  (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
  (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
  (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
  (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))

#+end_src

This adds a hook so our font setup runs on any org mode buffer:

#+begin_src emacs-lisp

(add-hook 'org-mode-hook #'pmf/org-font-setup)

#+end_src

** Basic Config

This section contains the basic configuration for =org-mode= plus the configuration for org-gtd and capture templates for org-gtd.

#+begin_src emacs-lisp

(setq org-directory "~/org")
(setq org-agenda-files
      '("~/org/calendar-beorg.org"
        "~/org/reminders-beorg.org"))

(after! org
  ;; Add a nice drop down carrot instead of the standard [..] when collapsed
  (setq org-ellipsis " ‚ñæ")

  ;; When we are done with a todo, log the time it completed
  (setq org-agenda-start-with-log-mode t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)

  ;; Override doom emacs org mode todo states to change WAITING to NEXT.
  ;; This might get removed as we use org-gtd entirely now.
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"     ; A task that needs doing & is ready to do
           "PROJ(p)"     ; A project, which usually contains other tasks
           "STRT(s)"     ; A task that is in progress
           "NEXT(n)"     ; A task that's on my list of things to do next
           "WAIT(w)"     ; This task is paused/on hold because I'm waiting for others
           "INBOX(i)"     ; An unconfirmed and unapproved task or notion
           "|"
           "DONE(d)"     ; Task successfully completed
           "CANCEL(c)")))    ; Task was cancelled, aborted, or is no longer applicable

  (setq org-todo-keyword-faces
        '(("STRT"   . +org-todo-active)
          ("NEXT"   . +org-todo-onhold)
          ("WAIT"   . +org-todo-onhold)
          ("PROJ"   . +org-todo-project)
          ("CANCEL" . +org-todo-cancel))))
#+end_src

** Org clock settings

These are settings to ensure that if you clock in on a task, that the running clock persists across all buffers, even if they are non org buffers, and persists across restarts (in case emacs crashes). This is useful for helping to stay focused on a particular task until you've seen it thorugh completion.

#+begin_src emacs-lisp

(after! org
  ;; Persist clocks across restarts (optional but handy)
  (setq org-clock-persist 'history
        org-clock-in-resume t
        org-clock-out-remove-zero-time-clocks t
        org-clock-mode-line-total 'current) ; or 'today / 'auto

  (org-clock-persistence-insinuate)

  ;; Keep the modeline in sync when clock changes
  (add-hook 'org-clock-in-hook    #'org-clock-update-mode-line)
  (add-hook 'org-clock-out-hook   #'org-clock-update-mode-line)
  (add-hook 'org-clock-cancel-hook #'org-clock-update-mode-line))

#+end_src

** Org-gtd

Setup for using [[https://github.com/Trevoke/org-gtd.el][org-gtd]] which provides tooling to use the GTD (Getting Things Done) method inside of org mode.

This is a fix for a weird bug with org-gtd where it prompts us about upgrading, even though we've always been on the newest version. It must be declared *before* org-gtd gets started

#+begin_src emacs-lisp

(setq org-gtd-update-ack "3.0.0")

#+end_src

#+begin_src emacs-lisp

(use-package! org-gtd
  :after org
  :config
  (setq org-edna-use-inheritance t)
  (setq org-gtd-directory "~/org/gtd")
  (org-edna-mode)
  (map! :leader
        (:prefix ("l" . "org-gtd")
         :desc "Capture"           "c"  #'org-gtd-capture
         :desc "Engage"            "e"  #'my/org-gtd-engage
         :desc "Process inbox"     "p"  #'org-gtd-process-inbox
         :desc "Show all next"     "n"  #'org-gtd-show-all-next
         :desc "Set area of focus" "a"  #'org-gtd-area-of-focus-set-on-item-at-point
         :desc "Stuck projects"    "s"  #'org-gtd-review-stuck-projects))

  (map! :desc "Capture gtd item" "C-c c" #'org-gtd-capture)

  (map! :desc "Area of focus gtd item" "C-c a" #'org-gtd-area-of-focus-set-on-item-at-point)

  (map! :map org-gtd-clarify-map
        :desc "Organize this item" "C-c c" #'org-gtd-organize)

  ;; Setup capture templates to org-gtd inbox
  (setq org-gtd-capture-templates
        '(("i" "Inbox"
           entry  (file "~/org/gtd/inbox.org")
           "* %?\n%U\n\n"
           :kill-buffer t)
          ("l" "Inbox with link"
           entry (file "~/org/gtd/inbox.org")
           "* %?\n%U\n\n  %a"
           :kill-buffer t)
          ("s" "Slack"
           entry (file "~/org/gtd/inbox.org")
           "* [Slack thread w/ %^{Author}]: %?\n%U\n\n  %a"
           :kill-buffer t)
          ("e" "Email"
           entry (file "~/org/gtd/inbox.org")
           "* Respond to %:fromname: %:subject\n%U\n\n  %a"
           :immediate-finish t
           :kill-buffer t)))

  ;; Override the areas of focus with our own
  (setq org-gtd-areas-of-focus '("work" "coding" "music" "adventure" "family" "health" "home" "life"))

  ;; Add asking for area of focus when processing inbox
  (setq org-gtd-organize-hooks '(org-set-tags-command org-gtd-set-area-of-focus)))

#+end_src

*** Auto-Save GTD Buffers after Processing

This is a bit of a hack to ensure that all buffers are saved after we finish processing the inbox. I noticed without this that sometimes our inbox and tasks files were not properly saved and I lost data

#+begin_src emacs-lisp

(defun my/save-buffers-after-processing-inbox (&rest _)
  "Save all buffers after processing inbox."
  (save-some-buffers t))

(advice-add 'org-gtd-process--stop :after #'my/save-buffers-after-processing-inbox)

#+end_src

*** Custom Engage View
This creates functionality for setting a focus for the day. When launching our custom engage view, you will be prompted to enter a focus for the day if you have not already, which will be displayed visually after the calendar view in our custom engage view

#+begin_src emacs-lisp

;; Prompt for today's daily focus if not stored yet, otherwise get from file.
(defun my/org-gtd-get-daily-focus ()
  "Get or prompt for today's focus, stored in ~/org/gtd/focus.org."
  (let* ((today (format-time-string "%Y-%m-%d"))
         (focus-file (expand-file-name "focus.org" org-gtd-directory))
         (focus-text nil))
    ;; Try to read the focus from the file if it exists
    (when (file-exists-p focus-file)
      (with-temp-buffer
        (insert-file-contents focus-file)
        (goto-char (point-min))
        (when (re-search-forward (format "^\\* %s \\(.*\\)" (regexp-quote today)) nil t)
          (setq focus-text (match-string 1)))))
    ;; If not found, prompt user and append to the file
    (unless focus-text
      (setq focus-text (read-string "Set today's focus: "))
      (with-temp-buffer
        (when (file-exists-p focus-file)
          (insert-file-contents focus-file))
        (goto-char (point-max))
        (unless (bolp) (insert "\n"))
        (insert (format "* %s %s\n" today focus-text))
        (write-region (point-min) (point-max) focus-file)))
    focus-text))

#+end_src

Our custom engage view has the agenda for the day at the top, followed by a daily focus, a list of all open projects, and then next tasks grouped by areas of focus. Note that if a todo item does not have an area of focus assigned, it won't appear in this view at all.

#+begin_src emacs-lisp

(defun my/org-gtd-engage ()
  "Show custom GTD agenda view grouped by area of focus."
  (interactive)
  (org-gtd-core-prepare-agenda-buffers)
  (with-org-gtd-context
      ;; Step 1: get today's focus
      (let* ((daily-focus (my/org-gtd-get-daily-focus))

             ;; Step 2: create header block to display focus
             (focus-block
              `(tags "+FOCUS"
                ((org-agenda-overriding-header ,(format "Today's Focus üéØ: %s" daily-focus))
                 (org-agenda-ignore-drawer-properties t)
                 (org-agenda-skip-function (lambda () t)))))  ;; dummy block just to display header

             ;; Step 3: build remaining blocks
             (next-action-blocks
              (cl-loop for area in org-gtd-areas-of-focus
                       for matcher = (format "TODO=\"NEXT\"+CATEGORY=\"%s\"" area)
                       for entries = (org-map-entries (lambda () t) matcher 'agenda)
                       unless (null entries)
                       collect `(todo ,org-gtd-next
                                 ((org-agenda-overriding-header ,(format "%s Next Actions" (capitalize area)))
                                  (org-agenda-skip-function
                                   (lambda () (org-gtd-skip-unless-area-of-focus ,area)))))))

             (agenda-block
              `(agenda ""
                ((org-agenda-span 1)
                 (org-agenda-start-day nil)
                 (org-agenda-skip-additional-timestamps-same-entry t))))

             (project-block
              `(tags ,org-gtd-project-headings
                ((org-agenda-overriding-header "Active Projects")
                 (org-agenda-sorting-strategy '(category-down)))))

             (all-blocks (append (list agenda-block focus-block project-block) next-action-blocks))

             (org-agenda-custom-commands
              `(("x" "GTD Engage View"
                 ,all-blocks
                 ((org-agenda-buffer-name "*Org GTD Engage*"))))))
        (org-agenda nil "x")
        (goto-char (point-min)))))

#+end_src

** Nicer Heading Bullets

Doom uses [[https://github.com/minad/org-modern][org-modern]] if you add the =+pretty= flag to =init.el=. We can override settings to get custom bullet points on headers

#+begin_src emacs-lisp

(after! org-modern
  ;; Customize the symbols used for headlines
  (setq org-modern-hide-stars nil  ;; optional: show leading stars
        org-modern-star '(("‚óâ" "‚óã" "‚óè" "‚óã" "‚óè" "‚óã" "‚óè"))
        org-modern-fold-icons
        '((t . "‚ñ∏")
          (nil . "‚ñæ"))))

#+end_src

** Center Org Buffers

I use [[https://github.com/rnkn/olivetti][olivetti]] to center =org-mode= buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document.

#+begin_src emacs-lisp

(use-package! olivetti
  :after org
  :config
  ;; Configure column width to 100
  (setq olivetti-body-width 100)
  (setq olivetti-style t)

  ;; Turn on olivetti mode which centers the content among other things
  :hook (org-mode . olivetti-mode))

#+end_src

** Git gutters in org mode

This removes git gutters in org mode, as they distract from the experience of org mode document writing. Doom emacs already adds image-mode and pdf-view-mode to the not list, so we just expand it to include org-mode. Feel free to add any extra modes you would like ignored here.

#+begin_src emacs-lisp

(after! diff-hl
  (setq diff-hl-global-modes '(not image-mode pdf-view-mode org-mode)))

#+end_src

** Org habit
This turns on and configures org habit to work

#+begin_src emacs-lisp

;; Enable org-habit to show up in agenda view
(use-package! org-habit
  :after org
  :config
  (setq org-habit-show-all-today t)
  (setq org-habit-graph-column 60))

#+end_src

** Disable line mode
This disables line mode for a number of emacs modes, but most notably org mode

#+begin_src emacs-lisp

(dolist (mode '(org-mode-hook
                term-mode-hook
                vterm-mode-hook
                shell-mode-hook
                treemacs-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

** Structure Templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =ru= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

#+begin_src emacs-lisp

(after! org
  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("ru" . "src rust")))

#+end_src

** Auto-tangle Configuration Files

I used to have a helper here for auto formatting the tangled file, but I have since added this as a feature to doom emacs. If you would like to turn on auto formatting of the tangled output file, simply add the =+pretty= flag to the =literate= module in your =init.el= file. Note - this is not yet merged in. I will update this section when it is.

Separately, if you would like a helper function that can auto tangle all emacs-lisp blocks in an org file (like the one you are reading), you can use this helper function.

#+begin_src emacs-lisp

(defun pmf/org-indent-elisp-src-blocks ()
  "Indent all Emacs Lisp src blocks in the current Org buffer, then save."
  (interactive)
  (require 'ob) ;; ensure org-babel macros are loaded
  (save-excursion
    (org-babel-map-src-blocks nil ;; iterate over all babel blocks in current buffer
      (when (string= lang "emacs-lisp")
        (org-babel-do-in-edit-buffer
         (emacs-lisp-mode)
         (indent-region (point-min) (point-max)))))
    (save-buffer)))

#+end_src
** Auto save buffers after tangling

This was provided to me by the org-gtd guy - maybe get rid of my function above that hooks into org-gtd specifically and use this one instead.

#+begin_src emacs-lisp

(advice-add 'org-refile :after #'(lambda (&rest _) (org-save-all-org-buffers)))

#+end_src

* Development
** Lsp mode

*** lsp-ui

Turn off sideline entirely. I find it distracting.

#+begin_src emacs-lisp

(after! lsp-ui
  (setq lsp-ui-sideline-enable nil)
  (setq lsp-ui-sideline-show-hover nil))

#+end_src

*** Flycheck popup

This customizes the flycheck popup tooltip (for lsp diagnostics) to be better stylized by using flycheck-posframe. It fakes margins by drawing boxes underneath in the same color as the expected background colors, while maintaining severity colors for error/warn/info, and adds a small white border so the box pops a bit better as well

#+begin_src emacs-lisp

(use-package! flycheck-posframe
  :after flycheck
  :hook (flycheck-mode . flycheck-posframe-mode)
  :config
  ;; thin white outline
  (setq flycheck-posframe-border-width 1
        flycheck-posframe-position 'point)
  (set-face-attribute 'flycheck-posframe-border-face nil :foreground "white")

  (defun pmf/flycheck-posframe-simple-padding ()
    (let* ((bg  (or (face-background 'flycheck-posframe-face nil t)
                    (face-background 'tooltip nil t)
                    (face-background 'default nil t)))
           (pad 10)) ;; padding thickness
      ;; padding: draw a box in the same color as the background
      (set-face-attribute 'flycheck-posframe-face nil
                          :box `(:line-width ,pad :color ,bg))
      ;; severity faces: inherit colors from error/warning/etc,
      ;; and the box from the base face (no color overrides)
      (dolist (pair '((flycheck-posframe-error-face   . error)
                      (flycheck-posframe-warning-face . warning)
                      (flycheck-posframe-info-face    . shadow)))
        (set-face-attribute (car pair) nil
                            :inherit (list (cdr pair) 'flycheck-posframe-face)
                            :foreground 'unspecified
                            :background 'unspecified
                            :box 'unspecified))))

  (add-hook 'doom-load-theme-hook #'pmf/flycheck-posframe-simple-padding)
  (pmf/flycheck-posframe-simple-padding))

#+end_src

** Rust Development Setup

This adds configuration for rust development setup, including auto formatting all buffers on save. It also turns on clippy as our linter, which is somewhat aggressive, but I find useful for helping to improve our code quality.

#+BEGIN_SRC emacs-lisp

(after! rustic
  (setq +tree-sitter-hl-enabled-modes '(rust-mode))
  (add-hook 'rust-mode-hook #'tree-sitter-mode)
  (add-hook 'rust-mode-hook #'tree-sitter-hl-mode)

  (setq lsp-enable-semantic-highlighting t)
  (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
  (add-hook 'lsp-mode-hook #'lsp-semantic-tokens-mode)

  (setq lsp-rust-analyzer-cargo-watch-command "clippy")
  (setq lsp-rust-clippy-preference "on")

  (defun my/rust-enable-format-on-save ()
    (add-hook 'before-save-hook #'lsp-format-buffer nil t))

  (add-hook 'rust-mode-hook #'my/rust-enable-format-on-save))
#+END_SRC

*** REPL

To enable a Rust REPL, run the following shell command:

#+begin_src shell :tangle no

cargo install evcxr_repl

#+end_src

This section adds functionality to open a rust repl using doom emacs

#+begin_src emacs-lisp

;; Custom function to run evxcr for rust repl functionality
(defun pmf/rust-evcxr-repl ()
  "Start or switch to an evcxr REPL."
  (interactive)
  (unless (executable-find "evcxr")
    (user-error "evcxr not found on PATH. `cargo install evcxr_repl` then `doom env`"))
  (let* ((buf-name "*evcxr*")
         (buf (get-buffer buf-name)))
    (if (and buf (comint-check-proc buf))
        (pop-to-buffer buf)
      (let ((default-directory (or (and (fboundp 'projectile-project-root)
                                        (projectile-project-root))
                                   default-directory)))
        (pop-to-buffer (make-comint-in-buffer "evcxr" buf-name "evcxr" nil))))))

(after! rustic
  ;; Tell Doom's +eval to use rustic's REPL in rustic-mode
  (set-repl-handler! 'rust-mode #'pmf/rust-evcxr-repl))

#+end_src
*** Rust Playground

We can use the [[https://github.com/grafov/rust-playground][rust-playground]] package to get an impromptu local rust playground scratch pad which can be very useful.

Use =rust-playground= to spin up a new playground buffer. Once there you can type =C-c b= to flip back and forth between =main.rs= and =Cargo.toml= for adding packages as needed. Type =C-c C-c= to execute the playground and use the =rust-playground-upload= command to upload the buffer to rust playground website for sharing around!

** Magit and Forge

[[https://magit.vc/][Magit]] setup along with forge for my work Gitlab instance

You'll need to create a personal access token in Gitlab, and then provide it in your =.authinfo.gpg= file in the following format:

=machine gitlab.work-address.com login username^forge password <token here>=

#+begin_src emacs-lisp

;; Setup for magit forge with rumble gitlab instance
(setq auth-sources '("~/.authinfo.gpg"))
(after! forge
  (require 'forge-gitlab)
  (push '("git.rumble.work"           ; GITHOST in he remote URL
          "gitlab.rumble.work/api/v4" ; APIHOST (your web instance + API path)
          "gitlab.rumble.work"        ; WEBHOST (used for browsing)
          forge-gitlab-repository)    ; CLASS
        forge-alist))

#+END_SRC

** GPG Agent Fix

This fixes an issue I was having with getting emacs to find my gpg agent

#+BEGIN_SRC emacs-lisp

(setq epa-pinentry-mode 'loopback)
(setenv "GPG_TTY" (getenv "TTY"))

#+END_SRC

** Rainbow Delimiters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is useful in programming modes because it colorizes nested parentheses and brackets according to their nesting depth.  This makes it a lot easier to visually match parentheses in Emacs Lisp code without having to count them yourself.

#+begin_src emacs-lisp

(add-hook 'prog-mode 'rainbow-delimiters-mode)

#+end_src

** Eshell

Eshell seems far more limited than vterm, but might be useful as a scheme repl, and is supposedly highly customizable. This is a small nicities update for eshell. In =packages.el= I'm using =eshell-git-prompt=. This sets the theme to use powerline

#+begin_src emacs-lisp

(eshell-git-prompt-use-theme 'powerline)

#+end_src


** Org-Jira Configuration

This configures [[https://github.com/ahungry/org-jira][org-jira]] to point at my work jira, and excludes fields that would otherwise break issue creation and updating for my works particular jira board among other things

You'll also need to generate an access token in jira, and add it to your encrypted =.authinfo.gpg= file in the following format:

=machine seastead.atlassian.net login <work email> password <access-token> port 443=

#+BEGIN_SRC emacs-lisp
(use-package! org-jira
  :after org
  :config
  ;; Point at work jira
  (setq jiralib-url "https://seastead.atlassian.net")
  ;; These fields will break issue creation an updating as we don't have them.
  (setq jiralib-update-issue-fields-exclude-list '(priority components))

  ;; Map jira states back to known org todo states
  (setq org-jira-done-states '("Closed" "Resolved" "Done" "Cancelled"))
  (setq org-jira-jira-status-to-org-keyword-alist '(("To Do" . "TODO")
                                                    ("In Progress" . "STRT")
                                                    ("Done" . "DONE"))))
#+END_SRC

This adds a global mapping to retrieve issues without needing to be in an org-jira buffer, and more importantly adds custom hook functionality that does the following when =org-jira-todo-to-jira= function gets called:
 1. Inserts the new jira ticket number into the todo item header that generated the ticket as a prefix. For instance if the todo item was =* TODO Extend refresh token duration= and it created ticket =AUTH-200=, then the new header will be =* TODO AUTH-200: Extend refresh token duration=. This is a helper, so when we view our todo items we can easily create a branch associated with the ticket, which will automatically move the ticket to done when the branch is merged.
 2. It adds a link back to the org-jira ticket from the main todo. This allows us to divorce our internal todos from org-jira, but still have an easy way to go back to the main ticket for editing and updating ticket details, without having to pull up a browser

#+BEGIN_SRC emacs-lisp
(after! org-jira
  ;; Add mapping in org mode for org-jira-todo-to-jira - this needs to be
  ;; accessible from within org-mode generally. All org-jira keybindings are
  ;; currently scoped by the library to only work in org-jira mode, which is only
  ;; enabled on org-jira.org style files (pulled issues)
  (map! :leader
;;; <leader> j --- jira
        (:prefix-map ("j" . "jira")
         :desc "Get issues" "g" #'org-jira-get-issues))

  ;; Add logic so that when we call org-jira-todo-to-jira we insert a link to the
  ;; org-jira ticket line back onto the original todo item.
  (defvar my/org-jira--origin-marker nil
    "Marker pointing to the original Org TODO that spawned the JIRA issue.")

  (defvar my/org-jira--original-heading-text nil
    "Backup of the original TODO heading and its body.")

  ;; Before advice: store point + full heading text
  (defun my/org-jira--store-todo-entry ()
    (setq my/org-jira--origin-marker (point-marker))
    (let ((start (org-back-to-heading t))
          (end (save-excursion (org-end-of-subtree t t))))
      (setq my/org-jira--original-heading-text
            (buffer-substring-no-properties start end))))

  (defun my/org-jira--restore-todo-with-link ()
    (let (link-path link-desc ticket-id)
      ;; Step 1: get JIRA link and ticket ID from ~/.org-jira/AUTH.org
      (with-current-buffer (find-file-noselect "~/.org-jira/AUTH.org")
        (goto-char (point-max))
        (when (re-search-backward "^\\*+ +TODO\\b" nil t)
          (org-back-to-heading t)
          (let* ((link (org-store-link nil))
                 (parsed (org-link-unescape link)))
            (when (string-match "\\[\\[\\(.*?\\)\\]\\[\\(.*?\\)\\]\\]" parsed)
              (setq link-path (match-string 1 parsed))
              (setq link-desc (match-string 2 parsed)))
            ;; Extract ticket ID from heading text (e.g., AUTH-211)
            (when (re-search-forward "\\(AUTH-[0-9]+\\)" (org-entry-end-position) t)
              (setq ticket-id (match-string 1))))))

      ;; Step 2: switch back to original buffer and insert
      (when (and my/org-jira--origin-marker
                 (marker-buffer my/org-jira--origin-marker))
        (let ((origin-buf (marker-buffer my/org-jira--origin-marker)))
          (when (buffer-live-p origin-buf)
            (with-current-buffer origin-buf
              (goto-char my/org-jira--origin-marker)
              (insert my/org-jira--original-heading-text)
              ;; Move to heading and insert ticket ID prefix if available

              (save-excursion
                (org-back-to-heading t)
                (let* ((components (org-heading-components))
                       (todo (nth 2 components))
                       (heading (nth 4 components)))
                  ;; Only update heading if ticket-id is not already present
                  (when (and ticket-id
                             (not (string-prefix-p (concat ticket-id ": ") heading)))
                    ;; Reconstruct the full headline safely
                    (org-edit-headline
                     (format "%s: %s" ticket-id heading)))))

              ;; Move to end of heading and insert backlink
              (save-excursion
                (goto-char (org-entry-end-position))
                (insert "Linked JIRA ticket: ")
                (when link-path
                  (org-insert-link nil link-path link-desc))
                (insert "\n")))
            (switch-to-buffer origin-buf)
            (goto-char my/org-jira--origin-marker)
            (recenter))))))

  (advice-add 'org-jira-todo-to-jira :before #'my/org-jira--store-todo-entry)
  (advice-add 'org-jira-todo-to-jira :after  #'my/org-jira--restore-todo-with-link))
#+END_SRC

*** Forge PR Automation

This adds a hook that automatically injects the tip commit contents into the PR message when creating a PR from forge, and adds "Closes <Jira ID>" to the end of the PR description body if the branch name has the jira ticket in it.

#+BEGIN_SRC emacs-lisp

;; This is a custom function and hook that does the following:
;; 1. Intercepts when forge-create-pullreq gets called
;; 2. Grabs the jira ticket from the current branch
;; 3. Inserts the tip commit contents in as the PR contents (similar behavior to gitlab)
;; 4. Injects a "Closes <jira-ticket-id>" line into the PR details
(with-eval-after-load 'forge
  (defun my/forge--populate-pr-if-buffer ()
    "When PR buffer appears, auto-fill with commit body and JIRA ID."
    (when (string= (buffer-name) "new-pullreq")
      (remove-hook 'post-command-hook #'my/forge--populate-pr-if-buffer)
      (let* ((commit-msg (string-trim-right
                          (magit-git-output "log" "-1" "--pretty=%B")))
             (branch-name (magit-get-current-branch))
             (jira-id (when (string-match "\\bAUTH-[0-9]+\\b" branch-name)
                        (match-string 0 branch-name)))
             (closes-line (when jira-id (concat "\n\nCloses " jira-id)))
             (full-msg (concat commit-msg closes-line)))
        (goto-char (point-min))
        (when (looking-at "^#\\s-*")
          (replace-match (concat "# " full-msg))))))

  (defun my/forge--setup-auto-pr-body ()
    "Temporarily watch for the PR buffer to appear."
    (add-hook 'post-command-hook #'my/forge--populate-pr-if-buffer))

  ;; Use a safe advice wrapper that ignores arguments
  (advice-add 'forge-create-pullreq :after
              (lambda (&rest _) (my/forge--setup-auto-pr-body))))

#+END_SRC

* Slack Integration

This sets up integration with the [[https://github.com/emacs-slack/emacs-slack][slack plugin]], for use with my internal company, pulling cookie and token from an encrypted =auth-sources= file. It also enables alerting from the slack plugin

Note that this also enables automatic syntax highlighting of code blocks in Slack, leveraging the =language-detection= package by setting the =slack-block-highlight-source= variable to =t=.

To avoid putting your token and cookie into your config, you can load them into your encrypted =.authinfo.gpg= file, in the following formats.

For token: =machine rumbleinc.slack.com login peter.farr@rumble.com password <token here>=

For cookie: =machine rumbleinc.slack.com login peter.farr@rumble.com^cookie password <token here>=

Then differentiate between the two accordingly, as seen in the below config.

#+begin_src emacs-lisp

(use-package! slack
  :commands (slack-start)
  :bind (("C-c S K" . slack-stop)
         ("C-c S c" . slack-select-rooms)
         ("C-c S u" . slack-select-unread-rooms)
         ("C-c S U" . slack-user-select)
         ("C-c S m" . slack-im-open)
         ("C-c S s" . slack-search-from-messages)
         ("C-c S J" . slack-jump-to-browser)
         ("C-c S j" . slack-jump-to-app)
         ("C-c S e" . slack-insert-emoji)
         ("C-c S E" . slack-message-edit)
         ("C-c S r" . slack-message-add-reaction)
         ("C-c S t" . slack-thread-show-or-create)
         ("C-c S g" . slack-message-redisplay)
         ("C-c S G" . slack-conversations-list-update-quick)
         ("C-c S q" . slack-quote-and-reply)
         ("C-c S Q" . slack-quote-and-reply-with-link)
         ("C-c S T" . slack-all-threads)
         (:map slack-mode-map
               (("@" . slack-message-embed-mention)
                ("#" . slack-message-embed-channel)))
         (:map slack-thread-message-buffer-mode-map
               (("C-c '" . slack-message-write-another-buffer)
                ("@" . slack-message-embed-mention)
                ("#" . slack-message-embed-channel)))
         (:map slack-message-buffer-mode-map
               (("C-c '" . slack-message-write-another-buffer)))
         (:map slack-message-compose-buffer-mode-map
               (("C-c '" . slack-message-send-from-buffer)))
         )
  :config
  (slack-register-team
   :name "rumbleinc"
   :token (auth-source-pick-first-password
           :host "rumbleinc.slack.com"
           :user "peter.farr@rumble.com")
   :cookie (auth-source-pick-first-password
            :host "rumbleinc.slack.com"
            :user "peter.farr@rumble.com^cookie")
   :full-and-display-names t
   :default t
   :subscribed-channels '(rumble-sso-auth))

  (setq slack-block-highlight-source t))

(use-package alert
  :commands (alert)
  :init
  (setq alert-default-style 'notifier))

#+end_src

* Email

This sets up email using mu4e. Mu needs to be setup in advance. Please follow the [[https://docs.doomemacs.org/v21.12/modules/email/mu4e/][doom documentation on setting up email]] first.

For gmail, you'll need to setup an "app password" in your gmail settings, and use that as your password in your =.authinfo.gpg= file in a line that looks like this.

=machine smtp.gmail.com login farr.peterm@gmail.com password <app pass here>=

#+begin_src emacs-lisp

(after! mu4e
  ;; Each path is relative to the path of the maildir you passed to mu
  (set-email-account! "farr.peterm@gmail"
                      '((mu4e-sent-folder       . "/[Gmail].Sent Mail")
                        (mu4e-drafts-folder       . "/[Gmail].Drafts")
                        (mu4e-trash-folder       . "/[Gmail].Trash")
                        (mu4e-refile-folder       . "/[Gmail].All Mail")
                        (smtpmail-smtp-user     . "farr.peterm@gmail.com")
                        (mu4e-compose-signature . "Best,\nPeter Farr"))
                      t)

  ;; don't need to run cleanup after indexing for gmail
  (setq mu4e-index-cleanup nil
        ;; because gmail uses labels as folders we can use lazy check since
        ;; messages don't really "move"
        mu4e-index-lazy-check t)

  (setq
   user-mail-address "farr.peterm@gmail.com"
   user-full-name "Peter Farr"

   message-send-mail-function 'smtpmail-send-it
   send-mail-function 'smtpmail-send-it

   smtpmail-stream-type 'starttls
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587

   smtpmail-auth-supported '(login plain)
   smtpmail-smtp-user "farr.peterm@gmail.com"

   auth-sources '("~/.authinfo.gpg")

   smtpmail-debug-info t))


#+end_src

* Runtime Performance

Dial the GC threshold back down so that garbage collection happens more frequently but in less time.

#+begin_src emacs-lisp

;; Make gc pauses faster by decreasing the threshold.
(setq gc-cons-threshold (* 2 1000 1000))

#+end_src

